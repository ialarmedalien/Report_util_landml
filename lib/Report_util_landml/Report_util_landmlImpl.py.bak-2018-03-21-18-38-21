# -*- coding: utf-8 -*-
#BEGIN_HEADER
import os
import uuid
from Bio import SeqIO
from pprint import pprint, pformat
from AssemblyUtil.AssemblyUtilClient import AssemblyUtil
from KBaseReport.KBaseReportClient import KBaseReport
from DataFileUtil.DataFileUtilClient import DataFileUtil


#END_HEADER


class Report_util_landml:
    '''
    Module Name:
    Report_util_landml

    Module Description:
    A KBase module: Report_util_landml
This sample module for creating text report for data objects
    '''

    ######## WARNING FOR GEVENT USERS ####### noqa
    # Since asynchronous IO can lead to methods - even the same method -
    # interrupting each other, you must be *very* careful when using global
    # state. A method could easily clobber the state set by another while
    # the latter method is running.
    ######################################### noqa
    VERSION = "0.0.1"
    GIT_URL = "https://github.com/landml/Report_util_landml"
    GIT_COMMIT_HASH = "75e61cbf33462215193ba682716fbcfa89837320"

    #BEGIN_CLASS_HEADER
    def create_report(self, token, ws, uuid_string, read_file_path):
        # type: (object, object, object, object) -> object
        output_html_files = list()
        output_zip_files = list()
        first_file = ""
        html_string = ""
        html_count = 0
        with open('/kb/module/data/index_start.txt', 'r') as start_file:
            html_string = start_file.read()

        # Make HTML folder
        html_folder = os.path.join(read_file_path, 'html')
        os.mkdir(html_folder)
        for file in os.listdir(read_file_path):
            label = ".".join(file.split(".")[1:])
            if (file.endswith(".zip")):
                desc = 'Zip file generated by fastqc that contains ' + \
                       'original images seen in the report'
                output_zip_files.append({'path': os.path.join(read_file_path, file),
                                         'name': file,
                                         'label': label,
                                         'description': desc})
            if (file.endswith(".html")):
                # Move html into html folder
                shutil.move(os.path.join(read_file_path, file), os.path.join(html_folder, file))

                if (first_file == ""):
                    first_file = file

                html_string += "            <button data-button=\"page " + str(html_count) + \
                               "\" data-page=\"" + file + "\">Page " + str(html_count + 1) + "</button>\n"
                html_count += 1

        html_string += "        </div>    </div>    <div id=\"body\">\n"
        html_string += "        <iframe id=\"content\" "
        html_string += "style=\"width: 100%; border: none; \" src=\"" + first_file + "\"></iframe>\n    </div>"

        with open('/kb/module/data/index_end.txt', 'r') as end_file:
            html_string += end_file.read()

        with open(os.path.join(html_folder, "index.html"), 'w') as index_file:
            index_file.write(html_string)

        shock = self.dfu.file_to_shock({'file_path': html_folder,
                                        'make_handle': 0,
                                        'pack': 'zip'})
        desc = 'HTML files generated by fastqc that contains report on ' + \
               'quality of reads'
        output_html_files.append({'shock_id': shock['shock_id'],
                                  'name': 'index.html',
                                  'label': 'html files',
                                  'description': desc})

        report_params = {
            'direct_html_link_index': 0,
            'file_links': output_zip_files,
            'html_links': output_html_files,
            'workspace_name': ws,
            'report_object_name': 'kb_fastqc_report_' + uuid_string
        }
        kbase_report_client = KBaseReport(self.callback_url, token=token)
        output = kbase_report_client.create_extended_report(report_params)
        return output

    #END_CLASS_HEADER

    # config contains contents of config file in a hash or None if it couldn't
    # be found
    def __init__(self, config):
        #BEGIN_CONSTRUCTOR
        self.workspaceURL = config['workspace-url']
        self.callback_url = os.environ['SDK_CALLBACK_URL']
        self.scratch = os.path.abspath(config['scratch'])
        #END_CONSTRUCTOR
        pass


    def assembly_metadata_report(self, ctx, params):
        """
        The actual function is declared using 'funcdef' to specify the name
        and input/return arguments to the function.  For all typical KBase
        Apps that run in the Narrative, your function should have the 
        'authentication required' modifier.
        :param params: instance of type "AssemblyMetadataReportParams" (A
           'typedef' can also be used to define compound or container
           objects, like lists, maps, and structures.  The standard KBase
           convention is to use structures, as shown here, to define the
           input and output of your function.  Here the input is a reference
           to the Assembly data object, a workspace to save output, and a
           length threshold for filtering. To define lists and maps, use a
           syntax similar to C++ templates to indicate the type contained in
           the list or map.  For example: list <string> list_of_strings;
           mapping <string, int> map_of_ints;) -> structure: parameter
           "assembly_input_ref" of type "assembly_ref", parameter
           "workspace_name" of String, parameter "showContigs" of type
           "boolean" (A boolean. 0 = false, other = true.)
        :returns: instance of type "AssemblyMetadataResults" (Here is the
           definition of the output of the function.  The output can be used
           by other SDK modules which call your code, or the output
           visualizations in the Narrative.  'report_name' and 'report_ref'
           are special output fields- if defined, the Narrative can
           automatically render your Report.) -> structure: parameter
           "report_name" of String, parameter "report_ref" of String,
           parameter "report_content" of String
        """
        # ctx is the context object
        # return variables are: output
        #BEGIN assembly_metadata_report
        #END assembly_metadata_report

        # At some point might do deeper type checking...
        if not isinstance(output, dict):
            raise ValueError('Method assembly_metadata_report return value ' +
                             'output is not type dict as required.')
        # return the results
        return [output]
    def status(self, ctx):
        #BEGIN_STATUS
        returnVal = {'state': "OK",
                     'message': "",
                     'version': self.VERSION,
                     'git_url': self.GIT_URL,
                     'git_commit_hash': self.GIT_COMMIT_HASH}
        #END_STATUS
        return [returnVal]
