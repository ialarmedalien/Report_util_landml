# -*- coding: utf-8 -*-
#BEGIN_HEADER
import os
import uuid
from Bio import SeqIO
from pprint import pprint, pformat
from AssemblyUtil.AssemblyUtilClient import AssemblyUtil
from KBaseReport.KBaseReportClient import KBaseReport
from DataFileUtil.DataFileUtilClient import DataFileUtil


#END_HEADER


class Report_util_landml:
    '''
    Module Name:
    Report_util_landml

    Module Description:
    A KBase module: Report_util_landml
This sample module for creating text report for data objects
    '''

    ######## WARNING FOR GEVENT USERS ####### noqa
    # Since asynchronous IO can lead to methods - even the same method -
    # interrupting each other, you must be *very* careful when using global
    # state. A method could easily clobber the state set by another while
    # the latter method is running.
    ######################################### noqa
    VERSION = "0.0.1"
    GIT_URL = "https://github.com/landml/Report_util_landml"
    GIT_COMMIT_HASH = "75e61cbf33462215193ba682716fbcfa89837320"

    #BEGIN_CLASS_HEADER
    def create_report(self, token, ws, uuid_string, read_file_path):
        # type: (object, object, object, object) -> object
        output_html_files = list()
        output_zip_files = list()
        first_file = ""
        html_string = ""
        html_count = 0
        with open('/kb/module/data/index_start.txt', 'r') as start_file:
            html_string = start_file.read()

        # Make HTML folder
        html_folder = os.path.join(read_file_path, 'html')
        os.mkdir(html_folder)
        for file in os.listdir(read_file_path):
            label = ".".join(file.split(".")[1:])
            if (file.endswith(".zip")):
                desc = 'Zip file generated by fastqc that contains ' + \
                       'original images seen in the report'
                output_zip_files.append({'path': os.path.join(read_file_path, file),
                                         'name': file,
                                         'label': label,
                                         'description': desc})
            if (file.endswith(".html")):
                # Move html into html folder
                shutil.move(os.path.join(read_file_path, file), os.path.join(html_folder, file))

                if (first_file == ""):
                    first_file = file

                html_string += "            <button data-button=\"page " + str(html_count) + \
                               "\" data-page=\"" + file + "\">Page " + str(html_count + 1) + "</button>\n"
                html_count += 1

        html_string += "        </div>    </div>    <div id=\"body\">\n"
        html_string += "        <iframe id=\"content\" "
        html_string += "style=\"width: 100%; border: none; \" src=\"" + first_file + "\"></iframe>\n    </div>"

        with open('/kb/module/data/index_end.txt', 'r') as end_file:
            html_string += end_file.read()

        with open(os.path.join(html_folder, "index.html"), 'w') as index_file:
            index_file.write(html_string)

        shock = self.dfu.file_to_shock({'file_path': html_folder,
                                        'make_handle': 0,
                                        'pack': 'zip'})
        desc = 'HTML files generated by fastqc that contains report on ' + \
               'quality of reads'
        output_html_files.append({'shock_id': shock['shock_id'],
                                  'name': 'index.html',
                                  'label': 'html files',
                                  'description': desc})

        report_params = {
            'direct_html_link_index': 0,
            'file_links': output_zip_files,
            'html_links': output_html_files,
            'workspace_name': ws,
            'report_object_name': 'kb_fastqc_report_' + uuid_string
        }
        kbase_report_client = KBaseReport(self.callback_url, token=token)
        output = kbase_report_client.create_extended_report(report_params)
        return output

    #END_CLASS_HEADER

    # config contains contents of config file in a hash or None if it couldn't
    # be found
    def __init__(self, config):
        #BEGIN_CONSTRUCTOR
        self.workspaceURL = config['workspace-url']
        self.callback_url = os.environ['SDK_CALLBACK_URL']
        self.scratch = os.path.abspath(config['scratch'])
        #END_CONSTRUCTOR
        pass


    def assembly_metadata_report(self, ctx, params):
        """
        The actual function is declared using 'funcdef' to specify the name
        and input/return arguments to the function.  For all typical KBase
        Apps that run in the Narrative, your function should have the 
        'authentication required' modifier.
        :param params: instance of type "AssemblyMetadataReportParams" ->
           structure: parameter "assembly_input_ref" of type "assembly_ref",
           parameter "workspace_name" of String, parameter "showContigs" of type
           "boolean" (A boolean. 0 = false, other = true.)
        :returns: instance of type "AssemblyMetadataResults" -> structure:
           parameter "report_name" of String, parameter "report_ref" of String,
           parameter "report_content" of String
        """
        # ctx is the context object
        # return variables are: output
        #BEGIN assembly_metadata_report


        token = ctx['token']

        uuid_string = str(uuid.uuid4())

        write_file_path = self.scratch + "/" + uuid_string

        # Print statements to stdout/stderr are captured and available as the App log
        print('Starting Assembly MetaData Report Function. Params=')
        pprint(params)

        # Step 1 - Parse/examine the parameters and catch any errors
        print('Validating parameters.')
        if 'workspace_name' not in params:
            raise ValueError('Parameter workspace_name is not set in input arguments')
        workspace_name = params['workspace_name']
        if 'assembly_input_ref' not in params:
            raise ValueError('Parameter assembly_input_ref is not set in input arguments')
        assembly_input_ref = params['assembly_input_ref']
        if 'showContigs' not in params:
            raise ValueError('Parameter showContigs is not set in input arguments')
        showContigs_orig = params['showContigs']
        showContigs = None
        try:
            showContigs = int(showContigs_orig)
        except ValueError:
            raise ValueError('Cannot parse integer from showContigs parameter (' + str(showContigs_orig) + ')')
        if showContigs < 0:
            raise ValueError('showContigs parameter cannot be negative (' + str(showContigs) + ')')
        if showContigs > 1:
            raise ValueError('showContigs parameter cannot be greater than one (' + str(showContigs) + ')')

        # Step 2 - Download the input data as a Fasta and
        # We can use the AssemblyUtils module to download a FASTA file from our Assembly data object.
        # The return object gives us the path to the file that was created.
        print('Downloading Assembly data as a Fasta file.')
        #        assemblyUtil = AssemblyUtil(self.callback_url)
        #        fasta_file = assemblyUtil.get_assembly_as_fasta({'ref': assembly_input_ref})

        # Step 3 - Actually get the metadata.
        data_file_cli = DataFileUtil(self.callback_url)
        assembly_metadata = data_file_cli.get_objects({'object_refs': ['assembly_input_ref']})['data'][0]['data']

        string = "\nAssembly Metadata\n"
        list = ['assembly_id', 'dna_size', 'gc_content', 'num_contigs',
                'fasta_handle_ref', 'md5', 'type', 'taxon_ref']
        for item in list:
            if item in assembly_metadata:
                string += "\t{:20} = {}".format(item, assembly_metadata[item]) + "\n"

        if 'fasta_handle_info' in assembly_metadata and 'node_file_name' in assembly_metadata['fasta_handle_info']:
            string += "\tfilename             = " + assembly_metadata['fasta_handle_info']['node_file_name'] + "\n"
        string += "BASE counts\n"
        for base in assembly_metadata['base_counts']:
            string += "\t{:5} = {}".format(base, str(assembly_metadata['base_counts'][base])) + "\n"
        string += "\nName\tLength\tGC content\tContigID\tDescription\n"
        if 'contigs' in assembly_metadata:
            myContig = assembly_metadata['contigs']
            for ctg in myContig:
                list = ['length', 'gc_content', 'contig_id', 'description']
                string += ctg
                for item in list:
                    if item in myContig[ctg]:
                        string += "\t{}".format(myContig[ctg][item])
                    else:
                        string += "\t"
                string += "\n"

        report_path = os.path.join(write_file_path, 'assembly_metadata_report.txt')
        report_txt = open(report_path, "w")
        report_txt.write(string)
        report_txt.close()

        print string

        created_report = self.create_report(token, params['workspace_name'],
                                    uuid_string, write_file_path)

#        output = {'report_name': created_report['name'],
#                            'report_ref': created_report['ref']}

 #       print('returning: ' + pformat(output))

        output = {}
        # END assembly_metadata_report

        # At some point might do deeper type checking...
        if not isinstance(output, dict):
            raise ValueError('Method assembly_metadata_report return value ' +
                        'output is not type dict as required.')
        # return the results
#        return [output]


    def status(self, ctx):
        #BEGIN_STATUS
        returnVal = {'state': "OK",
                     'message': "",
                     'version': self.VERSION,
                     'git_url': self.GIT_URL,
                     'git_commit_hash': self.GIT_COMMIT_HASH}
        #END_STATUS
        return [returnVal]
